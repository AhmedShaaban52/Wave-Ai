[
  {
    "projectId": "30e2c33a-5169-4605-ab4e-647b547d99ba",
    "testId": "d10ddbc6-9bea-4215-b00c-71b4459af3e2",
    "userId": "14b894b8-a0f1-7067-345b-87dbcfaa5df9",
    "title": "TC001-health check endpoint authentication",
    "description": "Verify that the health check endpoint at GET / requires authentication and returns a successful response when accessed with valid session credentials.",
    "code": "import requests\n\ndef test_health_check_endpoint_authentication():\n    base_url = \"http://localhost:3000\"\n    url = f\"{base_url}/\"\n    headers = {\n        \"Authorization\": \"Bearer l6OHQemPNaMJBCD04DTGyVuF4r4Rvy2m.JSbslKu4FiAV6LT7o2LW7yS%2FBbkTt8q3Lo8UFKaR6QE%3D\"\n    }\n    timeout = 30\n\n    try:\n        response = requests.get(url, headers=headers, timeout=timeout)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    # No specific response body is defined in PRD for health check,\n    # so only checking for 200 status is sufficient.\n\ntest_health_check_endpoint_authentication()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-26T12:56:51.600Z",
    "modified": "2025-12-26T12:57:12.867Z"
  },
  {
    "projectId": "30e2c33a-5169-4605-ab4e-647b547d99ba",
    "testId": "89e4ce92-db92-4f13-8f9e-05e79a37a5b1",
    "userId": "14b894b8-a0f1-7067-345b-87dbcfaa5df9",
    "title": "TC002-send chat message and receive ai response",
    "description": "Test the POST /chat endpoint by sending a valid chat message payload including id, message object, selectedModelId, and selectedToolName, and verify that the AI response is returned correctly.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000/api\"\n\n\n# Use a session to handle session-based authentication\nsession = requests.Session()\n\n# Assuming login is required before accessing the endpoints; however, no login API here,\n# so simulate session with cookie if possible or just remove Authorization header as per PRD.\n\n\ndef test_send_chat_message_and_receive_ai_response():\n    url = f\"{BASE_URL}/chat\"\n\n    payload = {\n        \"id\": str(uuid.uuid4()),\n        \"message\": {\n            \"text\": \"Hello AI, please respond!\"\n        },\n        \"selectedModelId\": \"gpt-4\",\n        \"selectedToolName\": None\n    }\n\n    try:\n        # Send without Authorization header, assuming session-based auth is handled externally\n        response = session.post(url, json=payload, timeout=30)\n        # Assert status code 200 OK\n        assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n        data = response.json()\n        # Assert there is an AI response in the returned data and it contains expected keys\n        assert isinstance(data, dict), \"Response JSON is not a dict\"\n        # Assuming response contains a key like 'reply' or 'message' as AI response\n        assert \"reply\" in data or \"message\" in data, \"Response does not contain AI reply/message\"\n\n        # If 'reply' exists, verify it's a non-empty string\n        if \"reply\" in data:\n            assert isinstance(data[\"reply\"], str) and data[\"reply\"].strip() != \"\", \"AI reply is empty or not a string\"\n\n        # If 'message' exists, verify it is a dict with expected structure\n        if \"message\" in data:\n            assert isinstance(data[\"message\"], dict), \"AI message is not an object\"\n            # Possibly check it has 'text' or similar key\n            assert \"text\" in data[\"message\"], \"AI message object does not contain 'text' key\"\n            assert isinstance(data[\"message\"][\"text\"], str) and data[\"message\"][\"text\"].strip() != \"\", \"AI message text is empty or not a string\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n\ntest_send_chat_message_and_receive_ai_response()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 53, in <module>\n  File \"<string>\", line 30, in test_send_chat_message_and_receive_ai_response\nAssertionError: Expected status code 200, got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-26T12:56:51.606Z",
    "modified": "2025-12-26T12:57:45.791Z"
  },
  {
    "projectId": "30e2c33a-5169-4605-ab4e-647b547d99ba",
    "testId": "bff3b863-455e-407b-989d-f687283b7914",
    "userId": "14b894b8-a0f1-7067-345b-87dbcfaa5df9",
    "title": "TC003-create new note with valid data",
    "description": "Test the POST /note/create endpoint by creating a new note with valid title and content, and verify that the note is created successfully and associated with the authenticated user.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api\"\nTOKEN = \"l6OHQemPNaMJBCD04DTGyVuF4r4Rvy2m.JSbslKu4FiAV6LT7o2LW7yS%2FBbkTt8q3Lo8UFKaR6QE%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_create_new_note_with_valid_data():\n    url_create = f\"{BASE_URL}/note/create\"\n    note_data = {\n        \"title\": \"Test Note Title\",\n        \"content\": \"This is the content of the test note.\"\n    }\n\n    response = requests.post(url_create, json=note_data, headers=HEADERS, timeout=30)\n    assert response.status_code == 200 or response.status_code == 201, f\"Unexpected status code: {response.status_code}\"\n    resp_json = response.json()\n\n    # Verify response contains the correct data\n    assert resp_json.get(\"title\") == note_data[\"title\"], \"Title in response does not match request\"\n    assert resp_json.get(\"content\") == note_data[\"content\"], \"Content in response does not match request\"\n\n\ntest_create_new_note_with_valid_data()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 26, in <module>\n  File \"<string>\", line 22, in test_create_new_note_with_valid_data\nAssertionError: Title in response does not match request\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-26T12:56:51.611Z",
    "modified": "2025-12-26T12:57:53.235Z"
  },
  {
    "projectId": "30e2c33a-5169-4605-ab4e-647b547d99ba",
    "testId": "7b87b1da-d349-4039-a8e8-dbc3343623a3",
    "userId": "14b894b8-a0f1-7067-345b-87dbcfaa5df9",
    "title": "TC004-update existing note with partial data",
    "description": "Test the PATCH /note/update/:id endpoint by updating an existing note with partial data such as only title or only content, and verify that the note is updated correctly without affecting other fields.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api\"\nTOKEN = \"l6OHQemPNaMJBCD04DTGyVuF4r4Rvy2m.JSbslKu4FiAV6LT7o2LW7yS%2FBbkTt8q3Lo8UFKaR6QE%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\n\ndef test_update_existing_note_with_partial_data():\n    # Create a new note first to update it later\n    create_payload = {\n        \"title\": \"Original Title\",\n        \"content\": \"Original Content\"\n    }\n    create_resp = requests.post(f\"{BASE_URL}/note/create\", json=create_payload, headers=HEADERS, timeout=TIMEOUT)\n    assert create_resp.status_code == 200 or create_resp.status_code == 201, f\"Failed to create note: {create_resp.text}\"\n    note = create_resp.json()\n    assert isinstance(note, dict), f\"Note creation response is not a dict: {note}\"\n    note_id = note.get(\"id\") or note.get(\"_id\")\n    assert note_id, f\"Created note does not contain an ID, received keys: {list(note.keys())}\"\n\n    try:\n        # Get original note data for comparison\n        get_resp_before = requests.get(f\"{BASE_URL}/note/{note_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert get_resp_before.status_code == 200, f\"Failed to get note before update: {get_resp_before.text}\"\n        original_note = get_resp_before.json()\n        original_title = original_note.get(\"title\")\n        original_content = original_note.get(\"content\")\n\n        # Update only the title of the note (partial update)\n        partial_update_payload_title = {\n            \"title\": \"Updated Title\"\n        }\n        patch_resp_title = requests.patch(f\"{BASE_URL}/note/update/{note_id}\", json=partial_update_payload_title, headers=HEADERS, timeout=TIMEOUT)\n        assert patch_resp_title.status_code == 200, f\"Failed to partially update note title: {patch_resp_title.text}\"\n\n        # Verify that title is updated and content is unchanged\n        get_resp_after_title = requests.get(f\"{BASE_URL}/note/{note_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert get_resp_after_title.status_code == 200, f\"Failed to get note after title update: {get_resp_after_title.text}\"\n        updated_note_title = get_resp_after_title.json()\n        assert updated_note_title.get(\"title\") == \"Updated Title\", \"Title was not updated correctly\"\n        assert updated_note_title.get(\"content\") == original_content, \"Content was changed unintentionally during title update\"\n\n        # Update only the content of the note (partial update)\n        partial_update_payload_content = {\n            \"content\": \"Updated Content\"\n        }\n        patch_resp_content = requests.patch(f\"{BASE_URL}/note/update/{note_id}\", json=partial_update_payload_content, headers=HEADERS, timeout=TIMEOUT)\n        assert patch_resp_content.status_code == 200, f\"Failed to partially update note content: {patch_resp_content.text}\"\n\n        # Verify that content is updated and title is unchanged\n        get_resp_after_content = requests.get(f\"{BASE_URL}/note/{note_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert get_resp_after_content.status_code == 200, f\"Failed to get note after content update: {get_resp_after_content.text}\"\n        updated_note_content = get_resp_after_content.json()\n        assert updated_note_content.get(\"content\") == \"Updated Content\", \"Content was not updated correctly\"\n        assert updated_note_content.get(\"title\") == \"Updated Title\", \"Title was changed unintentionally during content update\"\n\n    finally:\n        # Clean up by deleting the created note\n        delete_resp = requests.delete(f\"{BASE_URL}/note/{note_id}\", headers=HEADERS, timeout=TIMEOUT)\n        assert delete_resp.status_code == 200 or delete_resp.status_code == 204, f\"Failed to delete note: {delete_resp.text}\"\n\n\ntest_update_existing_note_with_partial_data()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 67, in <module>\n  File \"<string>\", line 23, in test_update_existing_note_with_partial_data\nAssertionError: Created note does not contain an ID, received keys: ['success', 'data']\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-26T12:56:51.616Z",
    "modified": "2025-12-26T12:57:58.320Z"
  },
  {
    "projectId": "30e2c33a-5169-4605-ab4e-647b547d99ba",
    "testId": "cfcaa045-959a-4768-bf32-bed44063b6de",
    "userId": "14b894b8-a0f1-7067-345b-87dbcfaa5df9",
    "title": "TC005-get note by id with authentication",
    "description": "Verify that the GET /note/:id endpoint returns the correct note data for the given note ID when accessed with valid authentication, and returns appropriate error for invalid or unauthorized access.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api\"\nTOKEN = \"l6OHQemPNaMJBCD04DTGyVuF4r4Rvy2m.JSbslKu4FiAV6LT7o2LW7yS%2FBbkTt8q3Lo8UFKaR6QE%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_get_note_by_id_with_authentication():\n    note_data = {\n        \"title\": \"Test Note for GET\",\n        \"content\": \"This is a test note to verify GET /note/:id with authentication.\"\n    }\n\n    note_id = None\n\n    # Create note to get valid ID\n    try:\n        create_resp = requests.post(\n            f\"{BASE_URL}/note/create\",\n            json=note_data,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201 or create_resp.status_code == 200, f\"Unexpected status creating note: {create_resp.status_code}\"\n        created_note = create_resp.json()\n        assert \"id\" in created_note, \"Created note response missing 'id'\"\n        note_id = created_note[\"id\"]\n\n        # Test valid GET\n        get_resp = requests.get(\n            f\"{BASE_URL}/note/{note_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert get_resp.status_code == 200, f\"GET note failed with status {get_resp.status_code}\"\n        note = get_resp.json()\n        assert note.get(\"id\") == note_id, \"Returned note id mismatch\"\n        assert note.get(\"title\") == note_data[\"title\"], \"Returned note title mismatch\"\n        assert note.get(\"content\") == note_data[\"content\"], \"Returned note content mismatch\"\n\n        # Test invalid note ID (random/likely non-existent)\n        invalid_id = \"nonexistent-note-id-123456\"\n        get_invalid_resp = requests.get(\n            f\"{BASE_URL}/note/{invalid_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        # Assuming 404 or 400 for not found\n        assert get_invalid_resp.status_code in {400, 404}, f\"Expected 400 or 404 for invalid note id, got {get_invalid_resp.status_code}\"\n\n        # Test unauthorized access with no token\n        no_auth_resp = requests.get(\n            f\"{BASE_URL}/note/{note_id}\",\n            timeout=TIMEOUT\n        )\n        assert no_auth_resp.status_code in {401, 403}, f\"Expected 401 or 403 for unauthorized access, got {no_auth_resp.status_code}\"\n\n        # Test unauthorized access with invalid token\n        invalid_headers = HEADERS.copy()\n        invalid_headers[\"Authorization\"] = \"Bearer invalid.token.here\"\n        invalid_auth_resp = requests.get(\n            f\"{BASE_URL}/note/{note_id}\",\n            headers=invalid_headers,\n            timeout=TIMEOUT\n        )\n        assert invalid_auth_resp.status_code in {401, 403}, f\"Expected 401 or 403 for invalid token, got {invalid_auth_resp.status_code}\"\n\n    finally:\n        if note_id:\n            # Clean up created note\n            requests.delete(\n                f\"{BASE_URL}/note/{note_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n\ntest_get_note_by_id_with_authentication()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 80, in <module>\n  File \"<string>\", line 29, in test_get_note_by_id_with_authentication\nAssertionError: Created note response missing 'id'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-26T12:56:51.621Z",
    "modified": "2025-12-26T12:58:05.019Z"
  },
  {
    "projectId": "30e2c33a-5169-4605-ab4e-647b547d99ba",
    "testId": "8b90b95d-fbd1-4760-8673-2eb21a04ae21",
    "userId": "14b894b8-a0f1-7067-345b-87dbcfaa5df9",
    "title": "TC006-delete note with valid authentication",
    "description": "Test the DELETE /note/:id endpoint to delete a note by ID, ensuring that the note is removed successfully and cannot be accessed afterwards, with proper authentication enforced.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api\"\nTOKEN = \"l6OHQemPNaMJBCD04DTGyVuF4r4Rvy2m.JSbslKu4FiAV6LT7o2LW7yS%2FBbkTt8q3Lo8UFKaR6QE%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\n\ndef test_delete_note_with_valid_authentication():\n    note_create_url = f\"{BASE_URL}/note/create\"\n    note_url_template = f\"{BASE_URL}/note/{{}}\"\n\n    # Step 1: Create a new note to delete\n    note_data = {\n        \"title\": \"Test Note to Delete\",\n        \"content\": \"This note will be deleted in the test.\"\n    }\n\n    response_create = requests.post(note_create_url, json=note_data, headers=HEADERS, timeout=TIMEOUT)\n    assert response_create.status_code == 200 or response_create.status_code == 201, f\"Failed to create note, status code: {response_create.status_code}\"\n    note = response_create.json()\n    note_id = note.get('id')\n    assert note_id is not None, f\"Created note ID is missing in response: {note}\"\n\n    try:\n        # Step 2: Delete the created note\n        delete_url = note_url_template.format(note_id)\n        response_delete = requests.delete(delete_url, headers=HEADERS, timeout=TIMEOUT)\n        assert response_delete.status_code == 200 or response_delete.status_code == 204, f\"Failed to delete note, status code: {response_delete.status_code}\"\n\n        # Step 3: Verify the note is removed and cannot be accessed\n        response_get = requests.get(delete_url, headers=HEADERS, timeout=TIMEOUT)\n        # Expecting 404 Not Found or similar error because note should no longer exist\n        assert response_get.status_code == 404 or response_get.status_code == 400 or response_get.status_code == 410, \\\n            f\"Deleted note still accessible, status code: {response_get.status_code}\"\n\n    finally:\n        # Cleanup in case note was not deleted\n        requests.delete(note_url_template.format(note_id), headers=HEADERS, timeout=TIMEOUT)\n\n\ntest_delete_note_with_valid_authentication()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 45, in <module>\n  File \"<string>\", line 26, in test_delete_note_with_valid_authentication\nAssertionError: Created note ID is missing in response: {'success': True, 'data': {'id': '0f4489a9-8857-4525-ac47-131c2d8dbe80', 'title': 'Test Note to Delete', 'content': 'This note will be deleted in the test.', 'createdAt': '2025-12-26T12:57:59.875Z', 'updatedAt': '2025-12-26T12:57:59.875Z', 'userId': 'DxCIy5EAQmkGYGnmDEmKJEXNULotVQTg'}}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-26T12:56:51.626Z",
    "modified": "2025-12-26T12:58:01.446Z"
  },
  {
    "projectId": "30e2c33a-5169-4605-ab4e-647b547d99ba",
    "testId": "53f2b813-5ac5-4889-9d3b-b90a2a07c901",
    "userId": "14b894b8-a0f1-7067-345b-87dbcfaa5df9",
    "title": "TC007-upgrade user subscription plan",
    "description": "Test the POST /subscription/upgrade endpoint by submitting a valid plan value (PLUS or PREMIUM) and callbackUrl, and verify that the user's subscription plan is upgraded accordingly with proper session authentication.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000/api\"\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_upgrade_user_subscription_plan():\n    url = f\"{BASE_URL}/subscription/upgrade\"\n    payloads = [\n        {\"plan\": \"PLUS\", \"callbackUrl\": \"https://example.com/callback/plus\"},\n        {\"plan\": \"PREMIUM\", \"callbackUrl\": \"https://example.com/callback/premium\"}\n    ]\n\n    for payload in payloads:\n        try:\n            response = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n            assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n        except requests.RequestException as e:\n            assert False, f\"Request failed: {e}\"\n\ntest_upgrade_user_subscription_plan()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 23, in <module>\n  File \"<string>\", line 19, in test_upgrade_user_subscription_plan\nAssertionError: Expected 200 OK, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-26T12:56:51.631Z",
    "modified": "2025-12-26T12:57:45.202Z"
  }
]
